generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  // The 'url' property is deprecated in Prisma 5. Move your connection URL to prisma.config.ts.
}

model accounts {
  id                Int     @id @default(autoincrement())
  userId            Int     @map("user_id")
  type              String  @db.VarChar(255)
  provider          String  @db.VarChar(255)
  providerAccountId String  @map("provider_account_id") @db.VarChar(255)
  refreshToken      String? @map("refresh_token")
  accessToken       String? @map("access_token")
  expiresAt         Int?    @map("expires_at")
  idToken           String? @map("id_token")
  scope             String?
  sessionState      String? @map("session_state")
  tokenType         String? @map("token_type")
  user              users   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model sessions {
  id           Int      @id @default(autoincrement())
  userId       Int      @map("user_id")
  expires      DateTime @db.Timestamptz(6)
  sessionToken String   @map("session_token") @db.VarChar(255)
  users        users    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([sessionToken])
  @@map("sessions")
}

model users {
  image                   String?
  createdAt               DateTime             @default(now()) @map("created_at") @db.Timestamptz(6)
  id                      Int                  @id @default(autoincrement())
  name                    String?              @db.VarChar(255)
  email                   String               @unique @db.VarChar(255)
  password                String?
  username                String?              @unique @db.VarChar(50)
  // predictions     predictions[]
  groupPredictions        groupPredictions[]
  groupMessages           groupMessages[]
  groupMessageReads       groupMessageReads[]
  accounts                accounts[]
  sessions                sessions[]
  role                    userRole             @default(user)
  refreshSessions         refreshSessions[]
  emailVerifiedAt         DateTime?            @map("email_verified_at") @db.Timestamptz(6)
  lastLoginAt             DateTime?            @map("last_login_at") @db.Timestamptz(6)
  userProfiles            userProfiles[]
  // publicPredictions publicPredictions[]
  userActivityEvents      userActivityEvents[]
  fixturesScoreOverridden fixtures[]           @relation("FixtureScoreOverriddenBy")

  // groups groups[]

  @@index([username], map: "idx_users_username")
}

model userProfiles {
  userId            Int       @unique(map: "user_profiles_user_id_unique") @map("user_id")
  level             Int       @default(1)
  dailyStreak       Int       @default(0) @map("daily_streak")
  lastClaimAt       DateTime? @map("last_claim_at") @db.Timestamptz(6)
  updatedAt         DateTime  @default(now()) @map("updated_at") @db.Timestamptz(6)
  id                Int       @id @default(autoincrement())
  favouriteTeamId   Int?      @map("favourite_team_id")
  favouriteLeagueId Int?      @map("favourite_league_id")
  onboardingDone    Boolean   @default(false) @map("onboarding_done")
  onboardingDoneAt  DateTime? @map("onboarding_done_at") @db.Timestamptz(6)
  users             users     @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@index([lastClaimAt(sort: Desc)], map: "user_profile_last_claim_idx")
  @@map("user_profiles")
}

model refreshSessions {
  id        Int       @id @default(autoincrement())
  userId    Int       @map("user_id")
  tokenHash String    @map("token_hash")
  expiresAt DateTime  @map("expires_at") @db.Timestamptz(6)
  revokedAt DateTime? @map("revoked_at")
  createdAt DateTime  @default(now()) @map("created_at") @db.Timestamptz(6)
  user      users     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([tokenHash], map: "refresh_sessions_token_hash_uniq")
  @@index([userId])
  @@map("refresh_sessions")
}

model verificationToken {
  identifier String
  expires    DateTime @db.Timestamptz(6)
  token      String

  @@id([identifier, token])
  @@map("verification_token")
}

enum userRole {
  admin
  user

  @@map("user_role")
}

model bookmakers {
  createdAt  DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt  DateTime @default(now()) @map("updated_at") @db.Timestamptz(6)
  id         Int      @id @default(autoincrement())
  name       String   @unique
  externalId BigInt?  @unique @map("external_id")
  odds       odds[]
}

model countries {
  createdAt  DateTime  @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt  DateTime  @default(now()) @map("updated_at") @db.Timestamptz(6)
  id         Int       @id @default(autoincrement())
  name       String
  imagePath  String?   @map("image_path")
  iso2       String?   @db.VarChar(2)
  iso3       String?   @db.VarChar(3)
  active     Boolean?  @default(false)
  externalId BigInt    @unique @map("external_id")
  leagues    leagues[]
  teams      teams[]
}

model fixtures {
  createdAt           DateTime     @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt           DateTime     @default(now()) @map("updated_at") @db.Timestamptz(6)
  id                  Int          @id @default(autoincrement())
  leagueId            Int?         @map("league_id")
  seasonId            Int?         @map("season_id")
  homeTeamId          Int          @map("home_team_id")
  awayTeamId          Int          @map("away_team_id")
  name                String
  startIso            String       @map("start_iso")
  startTs             Int          @map("start_ts")
  state               FixtureState @default(NS)
  liveMinute          Int?         @map("live_minute")
  result              String?
  // period-specific scores (primary: homeScore90/awayScore90; ET/PEN optional)
  homeScore90         Int?         @map("home_score_90")
  awayScore90         Int?         @map("away_score_90")
  homeScoreET         Int?         @map("home_score_et")
  awayScoreET         Int?         @map("away_score_et")
  penHome             Int?         @map("pen_home")
  penAway             Int?         @map("pen_away")
  stage               String?
  round               String?
  externalId          BigInt       @unique @map("external_id")
  hasOdds             Boolean      @default(false) @map("has_odds")
  scoreOverriddenAt   DateTime?    @map("score_overridden_at") @db.Timestamptz(6)
  scoreOverriddenById Int?         @map("score_overridden_by_id")
  awayTeam            teams        @relation("fixtures_away_team_idToteams", fields: [awayTeamId], references: [id], onUpdate: NoAction)
  homeTeam            teams        @relation("fixtures_home_team_idToteams", fields: [homeTeamId], references: [id], onUpdate: NoAction)
  league              leagues?     @relation(fields: [leagueId], references: [id], onUpdate: NoAction)
  season              seasons?     @relation(fields: [seasonId], references: [id], onUpdate: NoAction)
  scoreOverriddenBy   users?       @relation("FixtureScoreOverriddenBy", fields: [scoreOverriddenById], references: [id], onDelete: SetNull)
  odds                odds[]
  // predictions    predictions[]
  // publicPredictions publicPredictions[]

  // relations
  groupFixtures    groupFixtures[] // group fixtures that have been created for this fixture
  fixtureJobEvents fixtureJobEvents[] // job events that have been processed for this fixture
  fixtureAuditLog  fixtureAuditLog[] // audit log for this fixture

  @@unique([homeTeamId, awayTeamId, startTs], map: "fixtures_home_away_start_uniq")
  @@index([id, startTs])
  @@index([awayTeamId], map: "idx_fixtures_away_team_id")
  @@index([homeTeamId], map: "idx_fixtures_home_team_id")
  @@index([leagueId], map: "idx_fixtures_league_id")
  @@index([seasonId], map: "idx_fixtures_season_id")
  @@index([startTs], map: "idx_fixtures_start_ts")
  @@index([startTs, state], map: "idx_fixtures_start_ts_state")
  @@index([state], map: "idx_fixtures_state")
  @@index([homeTeamId, awayTeamId, startTs], map: "idx_fixtures_teams_start")
  @@map("fixtures")
}

model leagues {
  id         Int        @id @default(autoincrement())
  countryId  Int        @map("country_id")
  name       String
  type       String
  imagePath  String?    @map("image_path")
  createdAt  DateTime   @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt  DateTime   @default(now()) @map("updated_at") @db.Timestamptz(6)
  shortCode  String?    @map("short_code")
  externalId BigInt     @unique @map("external_id")
  subType    String?    @map("sub_type")
  fixtures   fixtures[]
  country    countries? @relation(fields: [countryId], references: [id], onUpdate: NoAction)
  seasons    seasons[]

  // relations
  // groupRules groupRules[] @relation("groupRulesRelation")

  // indexes
  @@unique([countryId, name], map: "leagues_country_name_uniq")
  @@unique([name, countryId], map: "leagues_name_country_uniq")
  @@index([id], map: "idx_leagues_id")
  @@index([countryId], map: "leagues_country_idx")
}

model odds {
  createdAt           DateTime    @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt           DateTime    @default(now()) @map("updated_at") @db.Timestamptz(6)
  id                  Int         @id @default(autoincrement())
  externalId          BigInt      @unique @map("external_id")
  fixtureId           Int         @map("fixture_id")
  bookmakerId         Int?        @map("bookmaker_id")
  marketExternalId    BigInt      @map("market_external_id")
  marketDescription   String      @map("market_description")
  marketName          String      @map("market_name")
  sortOrder           Int         @map("sort_order")
  label               String
  name                String?
  handicap            String?
  total               String?
  value               String
  probability         String?
  winning             Boolean     @default(false)
  startingAt          String      @map("starting_at")
  startingAtTimestamp Int         @map("starting_at_timestamp")
  bookmakers          bookmakers? @relation(fields: [bookmakerId], references: [id], onUpdate: NoAction)
  fixtures            fixtures    @relation(fields: [fixtureId], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@index([fixtureId, marketExternalId, bookmakerId], map: "odds_fix_market_book_idx")
  @@index([startingAtTimestamp], map: "odds_start_ts_idx")
  @@index([fixtureId], map: "odds_fixture_idx")
  @@map("odds")
}

enum groupStatus {
  draft
  active
  ended

  @@map("group_status")
}

enum groupSelectionMode {
  games
  teams
  leagues

  @@map("group_selection_mode")
}

enum groupPrivacy {
  private
  public

  @@map("group_privacy")
}

model groups {
  id            Int             @id @default(autoincrement())
  createdAt     DateTime        @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt     DateTime        @updatedAt @map("updated_at") @db.Timestamptz(6)
  creatorId     Int             @map("creator_id")
  name          String
  description   String?         @db.VarChar(500)
  // welcomeMessage       String?         @map("welcome_message")
  // startingAt DateTime     @map("starting_at") @db.Timestamptz(6)
  // endingAt   DateTime     @map("ending_at") @db.Timestamptz(6)
  status        groupStatus     @default(draft)
  // oddsUpdateUntilStart Boolean         @default(false) @map("odds_update_until_start")
  // wager_type              String
  // wager_tokens_amount     Int?
  // wager_custom            Json?
  privacy       groupPrivacy    @default(private)
  inviteCode    String?         @unique @map("invite_code")
  groupFixtures groupFixtures[] @relation("groupFixturesRelation")

  // group_invites           groupInvites[]
  // group_member_invites    groupMemberInvites[]
  groupMembers       groupMembers[]       @relation("groupMembersRelation")
  groupMessages      groupMessages[]
  groupMessageReads  groupMessageReads[]
  userActivityEvents userActivityEvents[]

  // relations
  groupRules groupRules? @relation("groupRulesRelation")
  // users                users           @relation(fields: [creatorId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  // @@index([startingAt, endingAt], map: "groups_time_window_idx")

  @@index([creatorId])
  @@index([privacy])
  @@index([status])
}

enum groupKoRoundMode {
  FullTime
  ExtraTime
  Penalties

  @@map("group_ko_round_mode")
}

enum groupPredictionMode {
  MatchWinner
  CorrectScore

  @@map("group_prediction_mode")
}

enum groupInviteAccess {
  all
  admin_only

  @@map("group_invite_access")
}

enum groupMessageType {
  user_message
  system_event

  @@map("group_message_type")
}

/// This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
model groupRules {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @map("updated_at") @db.Timestamptz(6)
  groupId   Int      @map("group_id")

  // Group selection rules
  selectionMode   groupSelectionMode @default(games) @map("selection_mode")
  groupTeamsIds   Int[]              @map("group_teams_ids")
  groupLeaguesIds Int[]              @map("group_leagues_ids")

  // scoring for correct score predictions
  onTheNosePoints         Int @default(3) @map("on_the_nose_points")
  correctDifferencePoints Int @default(2) @map("correct_difference_points")
  outcomePoints           Int @default(1) @map("outcome_points")

  koRoundMode    groupKoRoundMode    @default(FullTime) @map("ko_round_mode")
  predictionMode groupPredictionMode @default(CorrectScore) @map("prediction_mode")
  maxMembers     Int                 @default(50) @map("max_members")
  inviteAccess   groupInviteAccess   @default(all) @map("invite_access")

  // Nudge feature settings
  nudgeEnabled       Boolean @default(true) @map("nudge_enabled")
  nudgeWindowMinutes Int     @default(60) @map("nudge_window_minutes")

  // ruleType     String    @map("rule_type")
  // leagueId  Int?     @map("league_id")
  // teamIds   Int[]    @map("team_ids")
  // windowFrom DateTime? @map("window_from") @db.Timestamptz(6)
  // windowTo   DateTime? @map("window_to") @db.Timestamptz(6)
  // freezeOdds   Boolean?  @default(true) @map("freeze_odds")
  // oddsFrozenAt DateTime? @map("odds_frozen_at") @db.Timestamptz(6)
  groups groups @relation("groupRulesRelation", fields: [groupId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  // leagues   leagues? @relation("groupRulesRelation", fields: [leagueId], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@unique([groupId], map: "group_rules_one_rule_per_group")
  @@index([groupId], map: "group_rules_group_idx")
  @@index([groupTeamsIds], type: Gin, map: "group_rules_teams_gin")
  @@index([groupLeaguesIds], type: Gin, map: "group_rules_leagues_gin")
  @@map("group_rules")
}

enum groupMembersStatus {
  joined
  left
  pending

  @@map("group_members_status")
}

enum groupMemberRoles {
  member
  admin
  owner

  @@map("group_member_roles")
}

model groupMembers {
  id        Int                @id @default(autoincrement())
  createdAt DateTime           @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt DateTime           @default(now()) @map("updated_at") @db.Timestamptz(6)
  groupId   Int                @map("group_id")
  userId    Int                @map("user_id")
  role      groupMemberRoles   @default(member)
  status    groupMembersStatus @default(joined)
  // invitedBy   Int?          @map("invited_by")
  // joinedAt    DateTime?     @map("joined_at") @db.Timestamptz(6)
  // leftAt      DateTime?     @map("left_at") @db.Timestamptz(6)
  groups    groups             @relation("groupMembersRelation", fields: [groupId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  // users_group_members_invited_byTousers users?             @relation("group_members_invited_byTousers", fields: [invitedBy], references: [id], onUpdate: NoAction)
  // users_group_members_user_idTousers    users              @relation("group_members_user_idTousers", fields: [userId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  // predictions predictions[]

  groupPredictions groupPredictions[]

  @@unique([groupId, userId], map: "group_members_unique")
  @@index([groupId], map: "group_members_group_idx")
  @@index([status])
  @@index([userId, groupId], map: "group_members_user_group_idx")
  @@index([userId], map: "group_members_user_idx")
  @@map("group_members")
}

model groupFixtures {
  id               Int                @id @default(autoincrement())
  createdAt        DateTime           @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt        DateTime           @default(now()) @map("updated_at") @db.Timestamptz(6)
  groupId          Int                @map("group_id")
  fixtureId        Int                @map("fixture_id")
  // frozenOdds Json?    @map("frozen_odds")
  // locked     Boolean  @default(false)
  fixtures         fixtures           @relation(fields: [fixtureId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  groups           groups             @relation("groupFixturesRelation", fields: [groupId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  // predictions predictions[]
  groupPredictions groupPredictions[]

  @@unique([groupId, fixtureId])
  @@unique([id, groupId], map: "group_fixtures_id_group_unique")
  @@index([fixtureId], map: "group_fixtures_fixture_idx")
  @@index([groupId], map: "group_fixtures_group_idx")
  // @@index([groupId, locked], map: "group_fixtures_group_locked_idx")
  @@map("group_fixtures")
}

// enum groupPredictionStatus {
//   pending
//   active
//   settled

//   @@map("group_prediction_status")
// }

model groupPredictions {
  id                  Int       @id @default(autoincrement())
  groupId             Int       @map("group_id")
  groupFixtureId      Int       @map("group_fixture_id")
  userId              Int       @map("user_id")
  // status              String   @default("active")
  placedAt            DateTime  @default(now()) @map("placed_at") @db.Timestamptz(6)
  settledAt           DateTime? @map("settled_at") @db.Timestamptz(6)
  points              String    @default(dbgenerated("0"))
  prediction          String
  winningCorrectScore Boolean   @default(false) @map("winning_correct_score")
  winningMatchWinner  Boolean   @default(false) @map("winning_match_winner")
  updatedAt           DateTime  @default(now()) @map("updated_at") @db.Timestamptz(6)

  // relations
  groupFixtures groupFixtures @relation(fields: [groupFixtureId, groupId], references: [id, groupId], onDelete: Cascade, onUpdate: NoAction, map: "predictions_group_fixture_fk")
  groupMembers  groupMembers  @relation(fields: [groupId, userId], references: [groupId, userId], onDelete: Cascade, onUpdate: NoAction, map: "predictions_member_fk")
  users         users         @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@unique([userId, groupFixtureId], map: "group_predictions_user_fixture_unique")
  @@index([groupFixtureId], map: "group_predictions_group_fixture_idx")
  @@index([groupId], map: "group_predictions_group_idx")
  @@index([userId, groupFixtureId], map: "group_predictions_user_gf_idx")
  @@index([userId], map: "group_predictions_user_idx")
  @@map("group_predictions")
}

model groupMessages {
  id        Int              @id @default(autoincrement())
  createdAt DateTime         @default(now()) @map("created_at") @db.Timestamptz(6)
  groupId   Int              @map("group_id")
  senderId  Int?             @map("sender_id") // null for system events
  type      groupMessageType @default(user_message)
  body      String // text or event description
  meta      Json? // { mentions: [...] } or { eventType, ...data }

  groups groups @relation(fields: [groupId], references: [id], onDelete: Cascade)
  sender users? @relation(fields: [senderId], references: [id], onDelete: SetNull)

  @@index([groupId, id(sort: Desc)])
  @@map("group_messages")
}

model groupMessageReads {
  id                Int      @id @default(autoincrement())
  groupId           Int      @map("group_id")
  userId            Int      @map("user_id")
  lastReadMessageId Int      @map("last_read_message_id")
  updatedAt         DateTime @default(now()) @updatedAt @map("updated_at") @db.Timestamptz(6)

  groups groups @relation(fields: [groupId], references: [id], onDelete: Cascade)
  user   users  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([groupId, userId])
  @@map("group_message_reads")
}

model userActivityEvents {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  userId    Int      @map("user_id")
  groupId   Int?     @map("group_id")
  eventType String   @map("event_type") // "prediction_reminder", future: "group_ended", etc.
  body      String // Human-readable text
  meta      Json     @default("{}") // { fixtureId, homeTeam, awayTeam, kickoffAt, groupName }
  read      Boolean  @default(false) // For future "mark as read"

  users  users   @relation(fields: [userId], references: [id], onDelete: Cascade)
  groups groups? @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt(sort: Desc)], map: "user_activity_events_user_created_idx")
  @@index([userId, eventType, meta], map: "user_activity_events_dedup_idx")
  @@map("user_activity_events")
}

model nudgeEvents {
  id           Int      @id @default(autoincrement())
  createdAt    DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  groupId      Int      @map("group_id")
  fixtureId    Int      @map("fixture_id")
  nudgerUserId Int      @map("nudger_user_id")
  targetUserId Int      @map("target_user_id")
  message      String? // הודעת preset (אופציונלי, Phase 2)
  snappedBack  Boolean  @default(false) @map("snapped_back") // Phase 2 gamification

  @@unique([groupId, fixtureId, nudgerUserId, targetUserId], map: "nudge_unique_per_fixture")
  @@index([targetUserId, createdAt(sort: Desc)])
  @@index([groupId, fixtureId])
  @@map("nudge_events")
}

/// This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
// model predictions {
//   id                         Int       @id @default(autoincrement())
//   createdAt                  DateTime  @default(now()) @map("created_at") @db.Timestamptz(6)
//   updatedAt                  DateTime  @default(now()) @map("updated_at") @db.Timestamptz(6)
//   userId                     Int       @map("user_id")
//   fixtureId                  Int       @map("fixture_id")
//   prediction                 String
//   settled                    Boolean   @default(false)
//   winningCorrectScore        Boolean   @default(false) @map("winning_correct_score")
//   winningMatchWinner         Boolean   @default(false) @map("winning_match_winner")
//   possibleMatchWinnerPoints  String    @default("0") @map("possible_match_winner_points")
//   possibleCorrectScorePoints String    @default("0") @map("possible_correct_score_points")
//   // stakeCoins                 Int?      @map("stake_coins")
//   // trophiesDelta              Int?      @map("trophies_delta")
//   // pointsDelta                Int?      @map("points_delta")
//   // winningCoins               Int?      @map("winning_coins")
//   settledAt                  DateTime? @map("settled_at")
//   seenAt                     DateTime? @map("seen_at")
//   frozenOdds                 Json      @map("frozen_odds")
//   placedAt                   DateTime  @default(now()) @map("placed_at") @db.Timestamptz(6)
//   fixture                    fixtures  @relation(fields: [fixtureId], references: [id], onDelete: Cascade, onUpdate: NoAction)
//   users                      users     @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: NoAction)

//   // group relations
//   groupMembers  groupMembers[]
//   groupFixtures groupFixtures[]

//   @@unique([userId, fixtureId], map: "public_predictions_uniq")
//   @@index([fixtureId, settled], map: "pred_fixture_settled_idx")
//   @@index([userId, placedAt(sort: Desc)], map: "pp_user_placed_desc_idx")
//   @@index([fixtureId], map: "idx_predictions_fixture_id")
//   @@index([fixtureId, userId], map: "idx_predictions_fixture_user")
//   @@index([userId], map: "idx_predictions_user_id")
//   @@index([fixtureId], map: "pp_fixture_idx")
//   @@index([settled], map: "pp_settled_idx")
//   @@index([userId], map: "pp_user_idx")
//   @@map("predictions")
// }

model seasons {
  createdAt  DateTime   @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt  DateTime   @default(now()) @map("updated_at") @db.Timestamptz(6)
  id         Int        @id @default(autoincrement())
  leagueId   Int        @map("league_id")
  name       String
  startDate  String     @map("start_date")
  endDate    String     @map("end_date")
  isCurrent  Boolean    @default(false) @map("is_current")
  externalId BigInt     @unique @map("external_id")
  fixtures   fixtures[]
  leagues    leagues?   @relation(fields: [leagueId], references: [id], onUpdate: NoAction)

  @@unique([leagueId, name], map: "seasons_league_name_uniq")
  @@index([isCurrent], map: "seasons_current_idx")
  @@index([leagueId], map: "seasons_league_idx")
  @@map("seasons")
}

model teams {
  id         Int        @id @default(autoincrement())
  countryId  Int?       @map("country_id")
  name       String
  shortCode  String?    @map("short_code")
  imagePath  String?    @map("image_path")
  founded    Int?
  type       String?
  createdAt  DateTime   @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt  DateTime   @default(now()) @map("updated_at") @db.Timestamptz(6)
  externalId BigInt     @unique @map("external_id")
  countries  countries? @relation(fields: [countryId], references: [id], onDelete: NoAction, onUpdate: NoAction)

  firstKitColor  String? @map("first_kit_color")
  secondKitColor String? @map("second_kit_color")
  thirdKitColor  String? @map("third_kit_color")

  // relations
  fixtures_fixtures_away_team_idToteams fixtures[] @relation("fixtures_away_team_idToteams")
  fixtures_fixtures_home_team_idToteams fixtures[] @relation("fixtures_home_team_idToteams")

  @@unique([name, countryId], map: "teams_name_country_unique")
  @@index([id], map: "idx_teams_id")
  @@index([name, countryId], map: "idx_teams_name_country")
  @@map("teams")
}

enum FixtureState {
  // Not started
  NS
  TBA
  DELAYED
  AU
  PENDING
  // In play
  INPLAY_1ST_HALF
  INPLAY_2ND_HALF
  INPLAY_ET
  INPLAY_PENALTIES
  // Breaks (still "live" — game in progress)
  HT
  BREAK
  EXTRA_TIME_BREAK
  PEN_BREAK
  // Finished
  FT
  AET
  FT_PEN
  // Cancelled / Interrupted
  CANCELLED
  POSTPONED
  SUSPENDED
  ABANDONED
  INTERRUPTED
  WO
  AWARDED
  DELETED

  @@map("fixture_state")
}

enum RunStatus {
  queued
  running
  success
  failed
  skipped

  @@map("run_status")
}

enum RunTrigger {
  auto
  manual

  @@map("run_trigger")
}

enum JobTriggerBy {
  cron_scheduler
  admin_ui
  api_call
  cli_command

  @@map("job_trigger_by")
}

model jobs {
  key          String   @id
  description  String?
  scheduleCron String?  @map("schedule_cron")
  enabled      Boolean  @default(true)
  meta         Json     @default("{}")
  createdAt    DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt    DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  runs jobRuns[]

  @@map("jobs")
}

model jobRuns {
  id            Int           @id @default(autoincrement())
  jobKey        String        @map("job_key")
  job           jobs          @relation(fields: [jobKey], references: [key], onDelete: Cascade)
  status        RunStatus
  startedAt     DateTime      @default(now()) @map("started_at") @db.Timestamptz(6)
  finishedAt    DateTime?     @map("finished_at") @db.Timestamptz(6)
  durationMs    Int?          @map("duration_ms")
  rowsAffected  Int?          @map("rows_affected")
  errorMessage  String?       @map("error_message")
  errorStack    String?       @map("error_stack")
  meta          Json          @default("{}")
  trigger       RunTrigger    @default(auto)
  triggeredBy   JobTriggerBy? @map("triggered_by")
  triggeredById String?       @map("triggered_by_id")

  fixtureAuditLog fixtureAuditLog[]

  @@index([jobKey, startedAt(sort: Desc)], map: "job_runs_job_key_started_at_idx")
  @@map("job_runs")
}

model fixtureAuditLog {
  id        Int      @id @default(autoincrement())
  fixtureId Int      @map("fixture_id")
  jobRunId  Int?     @map("job_run_id")
  source    String // "job" | "admin"
  changes   Json // { field: { old, new } }
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(6)

  fixture fixtures @relation(fields: [fixtureId], references: [id], onDelete: Cascade)
  jobRun  jobRuns? @relation(fields: [jobRunId], references: [id], onDelete: SetNull)

  @@index([fixtureId, createdAt(sort: Desc)])
  @@map("fixture_audit_log")
}

enum fixtureJobEventType {
  updated
  finished

  @@map("fixture_job_event_type")
}

model fixtureJobEvents {
  id          Int                 @id @default(autoincrement())
  fixtureId   Int                 @map("fixture_id")
  processedAt DateTime?           @map("processed_at") @db.Timestamptz(6)
  eventType   fixtureJobEventType @map("event_type")
  createdAt   DateTime            @default(now()) @map("created_at") @db.Timestamptz(6)

  // relations
  fixtures fixtures @relation(fields: [fixtureId], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@map("fixture_job_events")
}

model seedBatches {
  id            Int        @id @default(autoincrement())
  name          String
  version       String?
  status        RunStatus
  startedAt     DateTime   @default(now())
  finishedAt    DateTime?
  durationMs    Int?
  itemsTotal    Int        @default(0)
  itemsSuccess  Int        @default(0)
  itemsFailed   Int        @default(0)
  errorMessage  String?
  errorStack    String?
  meta          Json       @default("{}")
  trigger       RunTrigger @default(manual)
  triggeredBy   String?
  triggeredById String?

  items seedItems[]

  @@index([name, startedAt(sort: Desc)])
  @@map("seed_batches")
}

model seedItems {
  id           Int         @id @default(autoincrement())
  batchId      Int
  batch        seedBatches @relation(fields: [batchId], references: [id], onDelete: Cascade)
  itemKey      String?
  status       RunStatus
  errorMessage String?
  meta         Json        @default("{}")

  @@index([batchId])
  @@map("seed_items")
}

enum PublicPredictionStatus {
  upcoming
  active
  void
  won
  lost

  @@map("public_prediction_status")
}

// /// This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
// model publicPredictions {
//   id                         Int                    @id @default(autoincrement())
//   createdAt                  DateTime               @default(now()) @map("created_at") @db.Timestamptz(6)
//   updatedAt                  DateTime               @default(now()) @map("updated_at") @db.Timestamptz(6)
//   userId                     Int                    @map("user_id")
//   fixtureId                  Int                    @map("fixture_id")
//   prediction                 String
//   status                     PublicPredictionStatus @default(upcoming)
//   settled                    Boolean                @default(false)
//   winningCorrectScore        Boolean                @default(false) @map("winning_correct_score")
//   winningMatchWinner         Boolean                @default(false) @map("winning_match_winner")
//   possibleMatchWinnerPoints  String                 @default("0") @map("possible_match_winner_points")
//   possibleCorrectScorePoints String                 @default("0") @map("possible_correct_score_points")
//   stakeCoins                 Int?                   @map("stake_coins")
//   winningCoins               Int?                   @map("winning_coins")
//   winningPoints              String?                @map("winning_points")
//   frozenOdds                 Json                   @map("frozen_odds")
//   placedAt                   DateTime               @default(now()) @map("placed_at") @db.Timestamptz(6)
//   fixtures                   fixtures               @relation(fields: [fixtureId], references: [id], onDelete: Cascade, onUpdate: NoAction)
//   users                      users                  @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: NoAction)

//   @@unique([userId, fixtureId], map: "public_predictions_uniq")
//   @@index([userId, placedAt(sort: Desc)], map: "pp_user_placed_desc_idx")
//   @@index([fixtureId], map: "idx_public_predictions_fixture_id")
//   @@index([fixtureId, userId], map: "idx_public_predictions_fixture_user")
//   @@index([userId], map: "idx_public_predictions_user_id")
//   @@index([fixtureId], map: "pp_fixture_idx")
//   @@index([settled], map: "pp_settled_idx")
//   @@index([status], map: "pp_status_idx")
//   @@index([userId], map: "pp_user_idx")
//   @@map("public_predictions")
// }
